diff --git a/SConstruct b/SConstruct
index 211fe99..61b7033 100755
--- a/SConstruct
+++ b/SConstruct
@@ -19,7 +19,6 @@ Help("""
             'scons -c' to clean the build directory,
             'scons dbg=1' to build the debug version,
             'scons mpidbg=1' to build the MPI debug version (OCM debugging),
-            'scons timing=1' to enable timers for the optimized build,
             'scons extoll=1' or 'scons ib=1' to build EXTOLL or IB code exclusively.
       """)
 
@@ -41,9 +40,6 @@ libflags = []
 #At some point we need to check on this...
 #ccflags.extend(['-fno-strict-aliasing'])
 
-if int(ARGUMENTS.get('timing', 0)): # add timing macro to allow for use of in-place timers
-   ccflags.extend(['-DTIMING'])
-
 if int(ARGUMENTS.get('dbg', 0)): # set debug flags (no MPI debugging here)
    ccflags.extend(['-ggdb','-O0'])
    libflags.extend(['-ggdb','-O0'])
diff --git a/inc/util/timer.h b/inc/util/timer.h
deleted file mode 100755
index a986214..0000000
--- a/inc/util/timer.h
+++ /dev/null
@@ -1,262 +0,0 @@
-/**
- * @file timer.h
- * @brief Header for time measurement etc
- *
- * @author Romain Cledat, romain@cc.gatech.edu
- * @author Vishakha Gupta, vishakha@cc.gatech.edu
- * @author Alex Merritt, merritt.alex@gatech.edu (code refactoring)
- * @bug There might be a wastage of space
- *
- * TODO Need an example call trace for these functions. Or an explanation.
- */
-#ifndef TIMER_H_
-#define TIMER_H_
-
-// System includes
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <stdint.h>
-#include <time.h>
-
-/*-------------------------------------- DEFINITIONS -------------------------*/
-
-#define TIMERMSG_PREFIX	"[TIMER] "
-
-//Change this line to reflect the desired accuracy - this applies to all timers
-#define TIMER_ACCURACY NANOSECONDS
-
-/*-------------------------------------- DATA TYPES --------------------------*/
-
-enum answerUnit_t {
-		SECONDS,
-		MILLISECONDS,
-		MICROSECONDS,
-		NANOSECONDS
-};
-
-struct timer {
-	clockid_t id;
-	struct timespec s, e; // start, end
-	struct timespec accum;
-	bool isPaused;
-};
-
-/*-------------------------------------- MACROS ------------------------------*/
-
-#ifdef TIMING
-
-// Use these to declare some number of timers.
-#define TIMER_DECLARE1(t1) \
-	struct timer t1;
-#define TIMER_DECLARE2(t1,t2) \
-	struct timer t1,t2;
-#define TIMER_DECLARE3(t1,t2,t3) \
-	struct timer t1,t2,t3;
-#define TIMER_DECLARE4(t1,t2,t3,t4) \
-	struct timer t1,t2,t3,t4;
-
-#define TIMER_START(tim) \
-	do { \
-		timer_init(CLOCK_REALTIME, &tim); \
-		timer_start(&tim); \
-	} while (0)
-
-#define TIMER_PAUSE(tim)		timer_pause(&tim, TIMER_ACCURACY)
-#define TIMER_RESUME(tim)		timer_resume(&tim);
-#define TIMER_CLEAR(tim)		timer_reset(&tim)
-
-/** Stop the timer and store the measured value in clk (must be uint64_t). */
-#define TIMER_END(tim,clk)	((clk) = timer_end(&tim, TIMER_ACCURACY))
-
-#else	/* !TIMING */
-
-#define TIMER_DECLARE1(t1)
-#define TIMER_DECLARE2(t1,t2)
-#define TIMER_DECLARE3(t1,t2,t3)
-#define TIMER_DECLARE4(t1,t2,t3,t4)
-#define TIMER_START(tim)
-#define TIMER_PAUSE(tim)
-#define TIMER_RESUME(tim)
-#define TIMER_CLEAR(tim)
-#define TIMER_END(clk,tim)
-
-#endif	/* TIMING */
-/*-------------------------------------- FUNCTIONS ---------------------------*/
-
-static inline struct timer *
-timer_init_alloc(clockid_t id_)
-{ 
-	// Default id is CLOCK_REALTIME
-	struct timer *tm = (struct timer *)calloc(1, sizeof(struct timer));
-	tm->id = id_;
-	tm->isPaused = true;
-
-	tm->accum.tv_sec = 0;
-	tm->accum.tv_nsec = 0;
-
-	return tm;
-}
-
-static inline int
-timer_init(clockid_t id_, struct timer *tm)
-{ 
-	tm->id = id_;
-	tm->isPaused = true;
-
-	tm->accum.tv_sec = 0;
-	tm->accum.tv_nsec = 0;
-
-	return 0;
-}
-
-static inline void
-timer_destroy(struct timer *tm) 
-{ 
-	if (tm != NULL)
-		free(tm);
-}
-
-static void
-timer_start(struct timer *tm)
-{
-	tm->accum.tv_sec = 0;
-	tm->accum.tv_nsec = 0;
-	tm->isPaused = false;
-	if(clock_gettime(tm->id, &tm->s) != 0) {
-		perror("-- ERR -- HRTIMER: error in getting start time");
-	}
-}
-
-static void
-timer_reset(struct timer *tm)
-{
-	tm->accum.tv_sec = 0;
-	tm->accum.tv_nsec = 0;
-	tm->isPaused = false;
-}
-
-static uint64_t
-timer_end(struct timer *tm, enum answerUnit_t unit) 
-{
-	if(clock_gettime(tm->id, &tm->e) != 0) {
-		perror("-- ERR -- HRTimer: error in getting end time");
-		return 0;
-	}
-	if(!tm->isPaused) {
-		if((tm->e.tv_sec < tm->s.tv_sec) || 
-				(tm->e.tv_sec == tm->s.tv_sec && 
-				 	tm->e.tv_nsec < tm->s.tv_nsec)) { 
-			fprintf(stderr, "-- WAR -- HRTimer: Elapsed time was negative\n");
-		} 
-		else {
-			tm->accum.tv_sec += tm->e.tv_sec - tm->s.tv_sec;
-			if(tm->e.tv_nsec < tm->s.tv_nsec) {
-				tm->accum.tv_sec -= 1;
-				tm->e.tv_nsec += (long int)1e9;
-			}
-			tm->accum.tv_nsec += tm->e.tv_nsec - tm->s.tv_nsec;
-		}
-		while(tm->accum.tv_nsec >= 1e9) {
-			tm->accum.tv_sec += 1;
-			tm->accum.tv_nsec -= (long int)1e9;
-		}
-	}
-	switch(unit) {
-		case SECONDS:
-			return (uint64_t)tm->accum.tv_sec;
-		case MILLISECONDS:
-			return (uint64_t)tm->accum.tv_sec *1000 + (uint64_t)tm->accum.tv_nsec/(uint64_t)1e6;
-		case MICROSECONDS:
-			return (uint64_t)tm->accum.tv_sec * (uint64_t)1e6 + (uint64_t)tm->accum.tv_nsec/(uint64_t)1e3;
-		case NANOSECONDS:
-			return (uint64_t)tm->accum.tv_sec * (uint64_t)1e9 + (uint64_t)tm->accum.tv_nsec;
-	};
-	return 0; // To keep the compiler happy
-}
-
-static inline uint64_t
-timer_pause(struct timer *tm, enum answerUnit_t unit) 
-{
-	struct timespec temp ;
-	if(clock_gettime(tm->id, &tm->e) != 0) {
-		perror("-- ERR -- HRTimer: error in getting end time");
-		return 0;
-	}
-
-	temp.tv_sec = 0;
-	temp.tv_nsec = 0;
-
-	if((tm->e.tv_sec < tm->s.tv_sec) || 
-		(tm->e.tv_sec == tm->s.tv_sec && 
-		 	tm->e.tv_nsec < tm->s.tv_nsec)) { 
-		fprintf(stderr, "-- WAR -- HRTimer: Elapsed time was negative\n");
-	} 
-	else {
-		temp.tv_sec += tm->e.tv_sec - tm->s.tv_sec;
-		if(tm->e.tv_nsec < tm->s.tv_nsec) {
-			temp.tv_sec -= 1;
-			tm->e.tv_nsec += (unsigned long)1e9;
-		}
-		temp.tv_nsec += tm->e.tv_nsec - tm->s.tv_nsec;
-	}
-
-	while(temp.tv_nsec >= 1e9) {
-		temp.tv_sec +=1;
-		temp.tv_nsec -= (unsigned long)1e9;
-	}
-
-	tm->accum.tv_sec += temp.tv_sec;
-	tm->accum.tv_nsec += temp.tv_nsec;
-	while(tm->accum.tv_nsec >= 1e9) {
-		tm->accum.tv_sec += 1;
-		tm->accum.tv_nsec -= (unsigned long)1e9;
-	}
-
-	tm->isPaused = true;
-
-	switch(unit) {
-		case SECONDS:
-			return (uint64_t)temp.tv_sec;
-		case MILLISECONDS:
-			return (uint64_t)temp.tv_sec * 1000 + (uint64_t)temp.tv_nsec/(uint64_t)1e6;
-		case MICROSECONDS:
-			return (uint64_t)temp.tv_sec * (uint64_t)1e6 + (uint64_t)temp.tv_nsec/(uint64_t)1e3;;
-		case NANOSECONDS:
-			return (uint64_t)temp.tv_sec * (uint64_t)1e9 + (uint64_t)temp.tv_nsec;
-	};
-	return 0; // to keep the compiler happy
-}
-
-static inline void
-timer_resume(struct timer *tm) {
-	tm->isPaused = false;
-	if(clock_gettime(tm->id, &tm->s) != 0) {
-		perror("-- ERR -- HRTimer: error in getting start time");
-	}
-}
-
-static inline struct timespec
-timer_getTimeSpec(struct timer *tm) 
-{
-	return tm->accum;
-}
-
-static inline uint64_t
-timer_getTime(struct timer *tm, enum answerUnit_t unit) 
-{
-	switch(unit) {
-		case SECONDS:
-			return (uint64_t)tm->accum.tv_sec;
-		case MILLISECONDS:
-			return (uint64_t)tm->accum.tv_sec *1000 + (uint64_t)tm->accum.tv_nsec/(uint64_t)1e6;
-		case MICROSECONDS:
-			return (uint64_t)tm->accum.tv_sec * (uint64_t)1e6 + (uint64_t)tm->accum.tv_nsec/(uint64_t)1e3;
-		case NANOSECONDS:
-			return (uint64_t)tm->accum.tv_sec * (uint64_t)1e9 + (uint64_t)tm->accum.tv_nsec;
-	};
-	return 0; // To keep the compiler happy
-}
-
-#endif				/* TIMER_H_ */
diff --git a/rdma_serverbackup.c b/rdma_serverbackup.c
deleted file mode 100755
index 8dceaf4..0000000
--- a/rdma_serverbackup.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/* file: rdma_server.c
- * author: Alexander Merritt, merritt.alex@gatech.edu
- * desc: File taken from Adit Ranadive's commlib RDMA code and refactored for
- * OCM
- */
-
-/* System includes */
-#include <arpa/inet.h>
-#include <infiniband/arch.h>
-#include <infiniband/verbs.h>
-#include <netdb.h>
-#include <rdma/rdma_cma.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <errno.h>
-#include <time.h>
-
-/* Project includes */
-#include <io/rdma.h>
-#include <util/timer.h>
-#include <debug.h>
-
-/* Directory includes */
-#include "rdma.h"
-
-/* Internal definitions */
-
-/* Internal state */
-
-/* Private functions */
-
-/* Public functions */
-
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-int
-ib_server_connect(struct ib_alloc *ib)
-{
-  /* Set up Timer  */ 
-  #ifdef TIMING    
-  
-  uint64_t ib_mem_reg_ns = 0;
-  //total connection time
-  uint64_t ib_total_conn_ns =0;
-  TIMER_DECLARE1(ib_server_timer);
-  TIMER_START(ib_server_timer);
-  #endif
-
-   /* 1. Set up RDMA CM structures */
-
-    struct sockaddr_in addr;
-
-    if (!(ib->rdma.ch = rdma_create_event_channel()))
-        return -1;
-
-    if (rdma_create_id(ib->rdma.ch, &ib->rdma.listen_id, NULL, RDMA_PS_TCP))
-        return -1;
-
-    printf("Port number in server_connect is %d\n", ib->params.port);
-
-    addr.sin_family      = AF_INET;
-    addr.sin_port        = htons(ib->params.port);
-    //addr.sin_port        = 12345;
-    //inet_aton("10.0.0.2", (struct in_addr *)&addr.sin_addr.s_addr);
-    addr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-    /* Bind to local port and listen for
-     * connection request */
-    printf("addr.sin_port = %d\n", addr.sin_port);
-
-    if (rdma_bind_addr(ib->rdma.listen_id, (struct sockaddr *) &addr))
-    {
-        printf("addr.sin_port = %d\n", addr.sin_port);
-        printf("IP address is %s\n",inet_ntoa(addr.sin_addr));    
-        printf("rdma_bind_addr failed with errno %d\n", errno);
-        return -1;
-    }
-
-    if (rdma_listen(ib->rdma.listen_id, 1))
-        return -1;
-
-    printd("waiting for connection on port %d...\n", ib->params.port);
-    if (rdma_get_cm_event(ib->rdma.ch, &ib->rdma.evt)) /* blocks */
-        return -1;
-
-    printd("got connection\n");
-    if (ib->rdma.evt->event != RDMA_CM_EVENT_CONNECT_REQUEST)
-        return -1;
-
-    /* New CM identifier from client, used for subsequent reads/writes. */
-    ib->rdma.id = ib->rdma.evt->id;
-
-    rdma_ack_cm_event(ib->rdma.evt);
-
-    /* 2. Create verbs objects now that we know which device to use */
-
-    struct ibv_recv_wr recv_wr;
-
-    memset(&recv_wr, 0, sizeof(recv_wr));
-
-    if (!(ib->verbs.pd = ibv_alloc_pd(ib->rdma.id->verbs)))
-        return -1; 
-
-    if (!(ib->verbs.ch = ibv_create_comp_channel(ib->rdma.id->verbs)))
-        return -1; 
-
-    if (!(ib->verbs.cq =
-                ibv_create_cq(ib->rdma.id->verbs, 100,
-                    NULL, ib->verbs.ch, 0)))
-        return -1; 
-
-    if (ibv_req_notify_cq(ib->verbs.cq, 0)) 
-        return -1; 
-
-    uint32_t mr_flags =
-        (IBV_ACCESS_LOCAL_WRITE |
-         IBV_ACCESS_REMOTE_READ |
-         IBV_ACCESS_REMOTE_WRITE);
-
-  #ifdef TIMING    
-  uint64_t ib_mem_reg_ns = 0;
-  #endif
-  TIMER_DECLARE1(ib_server_timer);
-  TIMER_START(ib_server_timer);
-
-    if (!(ib->verbs.mr = ibv_reg_mr(ib->verbs.pd, (void*)ib->params.buf,
-                    ib->params.buf_len, mr_flags))) {
-        perror("RDMA memory registration");
-        return -1;
-    }
-  
-    TIMER_END(ib_server_timer, ib_mem_reg_ns);
-
-#ifdef TIMING
-  printf("[CONNECT] Time for ibv_reg_mr: %lu \n", ib_mem_reg_ns);
-#endif
-  //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_server_timer);
-  
-    printd("registered memory region (%lu bytes)\n",
-            ib->verbs.mr->length);
-
-    ib->verbs.qp_attr.cap.max_send_wr  = 2;
-    ib->verbs.qp_attr.cap.max_send_sge = 2;
-    ib->verbs.qp_attr.cap.max_recv_wr  = 2;
-    ib->verbs.qp_attr.cap.max_recv_sge = 2;
-
-    ib->verbs.qp_attr.send_cq = ib->verbs.cq;
-    ib->verbs.qp_attr.recv_cq = ib->verbs.cq;
-
-    ib->verbs.qp_attr.qp_type = IBV_QPT_RC;
-
-  #ifdef TIMING    
-  uint64_t ib_create_qp_ns = 0;
-#endif
-  TIMER_START(ib_server_timer);
-    if (rdma_create_qp(ib->rdma.id, ib->verbs.pd, &ib->verbs.qp_attr))
-        return -1;
-  
-  TIMER_END(ib_server_timer, ib_create_qp_ns);
-  
-#ifdef TIMING
-  printf("[CONNECT] Time for rdma_create_qp: %lu ns\n", ib_create_qp_ns);
-#endif
-
-    /* don't need to post a recv... */
-#if 0
-    struct ibv_sge sge;
-    sge.addr    = (uintptr_t) ib->params.buf;
-    sge.length  = ib->params.buf_len;
-    sge.lkey    = ib->verbs.mr->lkey;
-
-    struct ibv_recv_wr wr, *bad_wr;
-    memset(&wr, 0, sizeof(wr));
-    wr.sg_list  = &sge;
-    wr.num_sge  = 1;
-
-    if (ibv_post_recv(ib->rdma.id->qp, &wr, &bad_wr))
-        return 1;
-#endif
-
-    /* 3. Accept connection */
-
-    /* this data is sent to client */
-    struct __pdata_t pdata;
-    pdata.buf_rkey  = htonl(ib->verbs.mr->rkey);
-    pdata.buf_va    = htonll((uintptr_t)ib->params.buf);
-    pdata.buf_len   = htonll(ib->params.buf_len);
-    printd("sending client rkey %u va 0x%llu len %llu\n",
-            ib->verbs.mr->rkey, (unsigned long long)ib->params.buf,
-            (unsigned long long)ib->params.buf_len);
-
-    ib->rdma.param.responder_resources  = 2;
-    ib->rdma.param.private_data         = &pdata;
-    ib->rdma.param.private_data_len     = sizeof(pdata);
-    ib->rdma.param.initiator_depth      = 2;
-    ib->rdma.param.retry_count          = 10;
-    ib->rdma.param.rnr_retry_count      = 10;
-
-    printd("accepting connection\n");
-    if (rdma_accept(ib->rdma.id, &ib->rdma.param))
-        return -1;
-
-    if (rdma_get_cm_event(ib->rdma.ch, &ib->rdma.evt))
-        return -1;
-
-    if (ib->rdma.evt->event != RDMA_CM_EVENT_ESTABLISHED)
-        return -1;
-
-    rdma_ack_cm_event(ib->rdma.evt);
-
-    return 0;
-}
-  int
-ib_server_disconnect(struct ib_alloc *ib)
-{
-  ////////////////////
-  //IB Verbs events
-  //////////////////////
-  //-rdma_destroy_qp (use this instead of ibv_destroy_qp since we created the qp with rdma_create_qp)
-  //-ibv_dereg_mr
-  //-Can free the buffer at this point
-  //-ibv_destroy_cq
-  //-ibv_destroy_comp_channel
-  //-ibv_dealloc_pd
-  ////If we were using ibv device directly we would also need to call ibv_close_device
-  //
-  //////////////////////
-  //Connection Manager events
-  //////////////////////
-  //-rdma_destroy_id
-  //-rdma_destroy_event_channel
-  //
-  int rc = 0;
-
-  #ifdef TIMING    
-  uint64_t ib_total_disconnect_ns = 0;
-  uint64_t ib_fine_disconnect_ns = 0;
-  #endif
-
-  TIMER_DECLARE1(ib_disconnect_timer);
-  TIMER_START(ib_disconnect_timer);
-
-  TIMER_DECLARE1(ib_dis_fine_timer);
-  TIMER_START(ib_dis_fine_timer);
-    //Destroy the queue pair - returns void
-    rdma_destroy_qp(ib->rdma.id);
-  TIMER_END(ib_dis_fine_timer, ib_fine_disconnect_ns);
-  #ifdef TIMING
-    printf("[DISCONNECT] Time for rdma_destroy_qp: %lu ns \n", ib_fine_disconnect_ns);
-  #endif
-  //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_dis_fine_timer);
-
-  //------deregister pinned pages---------
-  TIMER_START(ib_dis_fine_timer);
-  if (ibv_dereg_mr(ib->verbs.mr))
-  {
-    fprintf(stderr, "failed to deregister MR\n");
-    rc = 1;
-  }
-  TIMER_END(ib_dis_fine_timer, ib_fine_disconnect_ns);
-  #ifdef TIMING
-    printf("[DISCONNECT] Time for ibv_dereg_mr: %lu ns \n", ib_fine_disconnect_ns);
-  #endif
-  //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_dis_fine_timer);
-
-
-  //Make sure to free the buffer, ib->ib_params.buf in the dealloc function
-  //free(res->buf);
-
-
-  if (ibv_destroy_cq(ib->verbs.cq))
-  {
-    fprintf(stderr, "failed to destroy CQ\n");
-    rc = 1;
-  }
-
-  if (ibv_destroy_comp_channel(ib->verbs.ch))
-  {
-    fprintf(stderr, "failed to destroy CQ channel\n");
-    rc = 1;
-  }
-
-  if (ibv_dealloc_pd(ib->verbs.pd))
-  {
-    fprintf(stderr, "failed to deallocate PD\n");
-    rc = 1;
-  }
-
-  rdma_destroy_id(ib->rdma.id);
-
-  rdma_destroy_event_channel(ib->rdma.ch);
-
-  TIMER_END(ib_disconnect_timer, ib_total_disconnect_ns);
-
-  #ifdef TIMING
-    printf("[DISCONNECT] Total time for ib_client_disconnect: %lu ns \n", ib_total_disconnect_ns);
-  #endif
-
-
-  return rc;
-}
diff --git a/src/extoll.h b/src/extoll.h
index c3ee52e..431fe95 100644
--- a/src/extoll.h
+++ b/src/extoll.h
@@ -13,10 +13,8 @@
 #include <sys/types.h>
 
 #include <fcntl.h>                                             
-#include <time.h>            
 #include <sys/mman.h>                                           
 #include <sys/ioctl.h>                                           
-#include <sys/time.h>                                             
 #include "/extoll2/include/pmap.h"
 #include "/extoll2/include/rma2.h"
 
diff --git a/src/extoll_client.c b/src/extoll_client.c
index a9e0f0a..b52d6b0 100755
--- a/src/extoll_client.c
+++ b/src/extoll_client.c
@@ -18,11 +18,9 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include <time.h>
 
 /* Project includes */
 #include <io/extoll.h>
-#include <util/timer.h>
 #include <debug.h>
 
 /* Directory includes */
@@ -38,30 +36,15 @@
 int extoll_client_connect(struct extoll_alloc *ex)
 {
  RMA2_ERROR rc;
-  #ifdef TIMING
-    uint64_t open_ns = 0;
-    uint64_t malloc_ns = 0;
-    uint64_t connect_ns = 0;
-    uint64_t register_ns = 0;
-    uint64_t total_setup_ns = 0;
-  #endif
-
-   TIMER_DECLARE1(setup_timer);
 
   printf("Setting up remote memory connection to node %d, vpid %d, and 0x%lx NLA with RMA2\n", ex->params.dest_node, ex->params.dest_vpid, ex->params.dest_nla);
 
-  TIMER_START(setup_timer);
     ex->rma.buf = (void*)malloc(ex->params.buf_len);
-  TIMER_END(setup_timer, malloc_ns);
-  TIMER_CLEAR(setup_timer);
   memset(ex->rma.buf, 0, ex->params.buf_len);
   printf("Region starts at %p\n", ex->rma.buf);
 
   printf("Opening port\n");
-  TIMER_START(setup_timer);
     rc=rma2_open(&(ex->rma.port));
-  TIMER_END(setup_timer, open_ns);
-  TIMER_CLEAR(setup_timer);
 
   if (rc!=RMA2_SUCCESS) 
   { 
@@ -70,10 +53,7 @@ int extoll_client_connect(struct extoll_alloc *ex)
   }
 
   //Must connect to the remote node for put/get operations
-  TIMER_START(setup_timer);
     rma2_connect(ex->rma.port, ex->params.dest_node, ex->params.dest_vpid, ex->rma.conn_type, &(ex->rma.handle));
-  TIMER_END(setup_timer, connect_ns);
-  TIMER_CLEAR(setup_timer);
 
   if (rc!=RMA2_SUCCESS) 
   { 
@@ -83,9 +63,7 @@ int extoll_client_connect(struct extoll_alloc *ex)
 
   printf("Registering with remote memory\n");
   //register pins the memory and associates it with an RMA2_Region
-  TIMER_START(setup_timer);
     rc=rma2_register(ex->rma.port, ex->rma.buf, ex->params.buf_len, &(ex->rma.region));
-  TIMER_END(setup_timer, register_ns);
   
   if (rc!=RMA2_SUCCESS) 
   { 
@@ -93,29 +71,15 @@ int extoll_client_connect(struct extoll_alloc *ex)
     return -1;
   }
 
-  #ifdef TIMING
-    total_setup_ns = malloc_ns + open_ns + connect_ns + register_ns;
-    printf("[CONNECT] malloc: %lu ns, open: %lu ns, connect : %lu ns, register %lu ns, total setup: %lu ns\n", malloc_ns, open_ns, connect_ns, register_ns, total_setup_ns);
-  #endif
-
   return 0;
 }
 
 int extoll_client_disconnect(struct extoll_alloc *ex)
 {
   RMA2_ERROR rc;
-  TIMER_DECLARE1(teardown_timer);
-
-  #ifdef TIMING
-    uint64_t disconnect_ns = 0;
-    uint64_t rma_close_ns = 0;
-  #endif
 
   printf("RMA2 disconnect\n");
-  TIMER_START(teardown_timer);
     rc=rma2_disconnect(ex->rma.port,ex->rma.handle);
-  TIMER_END(teardown_timer, disconnect_ns);
-  TIMER_CLEAR(teardown_timer);
 
   if (rc!=RMA2_SUCCESS) 
   { 
@@ -124,9 +88,7 @@ int extoll_client_disconnect(struct extoll_alloc *ex)
   }
 
   printf("Close the RMA port\n");
-  TIMER_START(teardown_timer);
     rc=rma2_close(ex->rma.port);
-  TIMER_END(teardown_timer, rma_close_ns);
 
   if (rc!=RMA2_SUCCESS) 
   { 
@@ -134,10 +96,6 @@ int extoll_client_disconnect(struct extoll_alloc *ex)
     return -1;
   }
 
-  #ifdef TIMING
-    printf("[DISCONNECT] Disconnect: %lu ns, rma2_close: %lu ns, Total Teardown: %lu ns\n", disconnect_ns, rma_close_ns, disconnect_ns + rma_close_ns);
-  #endif
-
   //Free the memory region and associated buffer
   free(ex->rma.region);
 
diff --git a/src/extoll_server.c b/src/extoll_server.c
index 0c22352..3984e19 100755
--- a/src/extoll_server.c
+++ b/src/extoll_server.c
@@ -15,11 +15,9 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <errno.h>
-#include <time.h>
 
 /* Project includes */
 #include <io/extoll.h>
-#include <util/timer.h>
 #include <debug.h>
 
 /* Directory includes */
@@ -39,22 +37,10 @@ int extoll_server_connect(struct extoll_alloc *ex)
   RMA2_ERROR rc;
   int mem_result = 0;
 
-  #ifdef TIMING  
-    uint64_t tot_setup_ns = 0;
-    uint64_t rma_open_ns = 0;
-    uint64_t malloc_ns = 0;
-    uint64_t rma_register_ns = 0;
-  #endif
-
-  TIMER_DECLARE1(tmp_timer);
-
   printf("extoll_server_connect:: local_buff_size_B is %lu B\n",ex->params.buf_len);
   //Note that posix_memalign does a malloc, so the buffer should not be allocated yet!
 
-  TIMER_START(tmp_timer);
       rc=rma2_open(&(ex->rma.port));
-  TIMER_END(tmp_timer, rma_open_ns);
-  TIMER_CLEAR(tmp_timer);
 
   if (rc!=RMA2_SUCCESS)
   {
@@ -62,10 +48,7 @@ int extoll_server_connect(struct extoll_alloc *ex)
     return -1;
   }
 
-  TIMER_START(tmp_timer);
     mem_result=posix_memalign((void**)&(ex->rma.buf),4096,ex->params.buf_len);
-  TIMER_END(tmp_timer, malloc_ns);
-  TIMER_CLEAR(tmp_timer);
 
   if (mem_result!=0)
   {
@@ -74,9 +57,7 @@ int extoll_server_connect(struct extoll_alloc *ex)
   }
 
   //Registration pins the pages in a manner similar to ibv_reg_mr for IB 
-  TIMER_START(tmp_timer);
     rc=rma2_register(ex->rma.port, ex->rma.buf, ex->params.buf_len, &(ex->rma.region));
-  TIMER_END(tmp_timer, rma_register_ns);
 
   if (rc!=RMA2_SUCCESS)
   {
@@ -84,11 +65,6 @@ int extoll_server_connect(struct extoll_alloc *ex)
     return -1;
   }
 
-  #ifdef TIMING
-    tot_setup_ns = rma_open_ns + malloc_ns + rma_register_ns;
-    printf("[CONNECT] rma2_open: %lu ns, Malloc mem: %lu ns, Registration: %lu ns, Total Setup: %lu ns\n", rma_open_ns, malloc_ns, rma_register_ns, tot_setup_ns);
-  #endif
- 
   ex->params.dest_node = rma2_get_nodeid(ex->rma.port);
   ex->params.dest_vpid = rma2_get_vpid(ex->rma.port);
   rma2_get_nla(ex->rma.region, 0, &(ex->params.dest_nla));
@@ -125,23 +101,12 @@ int extoll_server_disconnect(struct extoll_alloc *ex)
 
   RMA2_ERROR rc;
 
-  TIMER_DECLARE1(teardown_timer);
-
-  #ifdef TIMING
-    uint64_t unregister_ns = 0;
-    uint64_t rma_close_ns = 0;
-    uint64_t teardown_ns = 0;
-  #endif
-
   //Note that disconnect is not needed on this end, since we
   //never performed rma2_connect
 
   //Unregister the pages when the program is stopped
   printf("Unregister pages\n");
-  TIMER_START(teardown_timer);
     rc=rma2_unregister(ex->rma.port, ex->rma.region);
-  TIMER_END(teardown_timer, unregister_ns);
-  TIMER_CLEAR(teardown_timer);
 
   if (rc!=RMA2_SUCCESS) 
   {
@@ -152,10 +117,7 @@ int extoll_server_disconnect(struct extoll_alloc *ex)
 
   printf("Close the RMA port\n");
   ///rma_disconnect(port,handle);
-  TIMER_START(teardown_timer);
     rc=rma2_close(ex->rma.port);
-  TIMER_END(teardown_timer, rma_close_ns);
-  TIMER_CLEAR(teardown_timer);
 
   if (rc!=RMA2_SUCCESS) 
   {
@@ -163,11 +125,6 @@ int extoll_server_disconnect(struct extoll_alloc *ex)
     return -1;
   }
 
-  #ifdef TIMING
-    teardown_ns = unregister_ns + rma_close_ns;
-    printf("[DISCONNECT] Unregister pages: %lu ns, rma2_close: %lu ns, Total Teardown: %lu ns\n", unregister_ns, rma_close_ns, teardown_ns);
-  #endif
-
   free(ex->rma.buf);
 
   return 0;
diff --git a/src/rdma_client.c b/src/rdma_client.c
index 7aa0e18..2653836 100755
--- a/src/rdma_client.c
+++ b/src/rdma_client.c
@@ -18,11 +18,9 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include <time.h>
 
 /* Project includes */
 #include <io/rdma.h>
-#include <util/timer.h>
 #include <debug.h>
 
 /* Directory includes */
@@ -39,20 +37,6 @@
 int
 ib_client_connect(struct ib_alloc *ib)
 {
-    #ifdef TIMING
-    uint64_t ib_mem_reg_ns = 0;
-    uint64_t ib_create_qp_ns = 0;
-    uint64_t ib_total_conn_ns = 0;
-    uint64_t ib_total_conn_ns_sum =0;
-    //timer for total connection
-    TIMER_DECLARE1(ib_total_client_conn_timer);
- 
-    TIMER_DECLARE1(ib_client_timer);
-    
-    //start timer for client total connection time
-    TIMER_START(ib_total_client_conn_timer);
-    #endif
-     
     int err = 0, n;
     struct addrinfo *res, *t, hints;
     char *service;
@@ -88,21 +72,10 @@ ib_client_connect(struct ib_alloc *ib)
     if (err)
         return -1;
     
-    #ifdef TIMING
-    //stop timer to ignore wait blocks
-    TIMER_END(ib_total_client_conn_timer, ib_total_conn_ns);
-    ib_total_conn_ns_sum+= ib_total_conn_ns;
-    #endif
-
     /* pull and ack event */
     if (rdma_get_cm_event(ib->rdma.ch, &(ib->rdma.evt)))
         return -1;
     
-    #ifdef TIMING
-    //resume total connection timer
-    TIMER_START(ib_total_client_conn_timer);
-    #endif
-
     if (ib->rdma.evt->event != RDMA_CM_EVENT_ADDR_RESOLVED)
         return -1;
     rdma_ack_cm_event(ib->rdma.evt);
@@ -111,20 +84,10 @@ ib_client_connect(struct ib_alloc *ib)
     if (rdma_resolve_route(ib->rdma.id, RESOLVE_TIMEOUT_MS))
         return -1;
 
-    #ifdef TIMING
-    //stop timer to ignore wait blocks
-    TIMER_END(ib_total_client_conn_timer, ib_total_conn_ns);
-    ib_total_conn_ns_sum+= ib_total_conn_ns;
-    #endif
     /* pull and ack event */
     if (rdma_get_cm_event(ib->rdma.ch, &(ib->rdma.evt)))
         return -1;
 
-    #ifdef TIMING
-    //resume total connection timer
-    TIMER_START(ib_total_client_conn_timer);
-    #endif
-
     if (ib->rdma.evt->event != RDMA_CM_EVENT_ROUTE_RESOLVED)
         return -1;
     rdma_ack_cm_event(ib->rdma.evt);
@@ -149,18 +112,12 @@ ib_client_connect(struct ib_alloc *ib)
          IBV_ACCESS_REMOTE_READ |
          IBV_ACCESS_REMOTE_WRITE);
   
-    TIMER_START(ib_client_timer);
-
     if (!(ib->verbs.mr = ibv_reg_mr(ib->verbs.pd, ib->params.buf,
                     ib->params.buf_len, mr_flags))) {
         perror("RDMA memory registration");
         return -1;
     }
   
-    TIMER_END(ib_client_timer, ib_mem_reg_ns);
-   //Reset the timer so it can be reused
-    TIMER_CLEAR(ib_client_timer);
-
     printd("registered memory region (%lu bytes)\n",
             ib->verbs.mr->length);
 
@@ -176,12 +133,9 @@ ib_client_connect(struct ib_alloc *ib)
  
 
 
-    TIMER_START(ib_client_timer);
-
     if (rdma_create_qp(ib->rdma.id, ib->verbs.pd, &ib->verbs.qp_attr))
         return -1;
   
-    TIMER_END(ib_client_timer, ib_create_qp_ns);
       /* 3. Connect to server */
 
     //ib->rdma.param.responder_resources  = 2;
@@ -193,20 +147,9 @@ ib_client_connect(struct ib_alloc *ib)
     if (rdma_connect(ib->rdma.id, &ib->rdma.param))
         return -1;
 
-    #ifdef TIMING
-    //stop timer to ignore wait blocks
-    TIMER_END(ib_total_client_conn_timer, ib_total_conn_ns);
-    ib_total_conn_ns_sum+= ib_total_conn_ns;
-    #endif
-
     if (rdma_get_cm_event(ib->rdma.ch, &ib->rdma.evt))
         return -1;
 
-    #ifdef TIMING
-    //resume total connection timer
-    TIMER_START(ib_total_client_conn_timer);
-    #endif
-
     if (ib->rdma.evt->event != RDMA_CM_EVENT_ESTABLISHED)
         return -1;
 
@@ -220,13 +163,6 @@ ib_client_connect(struct ib_alloc *ib)
 
     rdma_ack_cm_event(ib->rdma.evt);
 
-    //print all timer results here
-    #ifdef TIMING
-    printf("[CONNECT] Time for ibv_reg_mr: %lu ns \n"
-           "[CONNECT] Time for rdma_create_qp: %lu ns\n"
-           "[CONNECT] Time for total server connection: %lu ns\n"
-           ,ib_mem_reg_ns, ib_create_qp_ns, ib_total_conn_ns_sum);
-    #endif
     return 0;
 }
 
@@ -253,35 +189,15 @@ ib_client_disconnect(struct ib_alloc *ib)
 
   int rc = 0;
 
-  #ifdef TIMING
-  uint64_t ib_total_disconnect_ns = 0;
-  uint64_t ib_destroy_qp_ns =0;
-  uint64_t ib_mem_dereg_ns = 0;
-  #endif
-
-  TIMER_DECLARE1(ib_disconnect_timer);
-  TIMER_START(ib_disconnect_timer);
-
-  TIMER_DECLARE1(ib_dis_fine_timer);
-  TIMER_START(ib_dis_fine_timer);
-  
     //Destroy the queue pair - returns void
     rdma_destroy_qp(ib->rdma.id);
   
-  TIMER_END(ib_dis_fine_timer, ib_destroy_qp_ns);
-  //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_dis_fine_timer);
-
   //------deregister pinned pages---------
-  TIMER_START(ib_dis_fine_timer);
   if (ibv_dereg_mr(ib->verbs.mr))
   {
     fprintf(stderr, "failed to deregister MR\n");
     rc = 1;
   }
-  TIMER_END(ib_dis_fine_timer, ib_mem_dereg_ns);
-  //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_dis_fine_timer);
 
   //Make sure to free the buffer, ib->ib_params.buf in the dealloc function
   //free(res->buf);
@@ -309,16 +225,6 @@ ib_client_disconnect(struct ib_alloc *ib)
 
   rdma_destroy_event_channel(ib->rdma.ch);
 
-  TIMER_END(ib_disconnect_timer, ib_total_disconnect_ns);
-  
-  //prints all timer results here
-  #ifdef TIMING
-  printf("[DISCONNECT] Time for ibv_dereg_mr: %lu ns \n"
-           "[DISCONNECT] Time for rdma_destroy_qp: %lu ns \n"
-           "[DISCONNECT] Total time for ib_client_disconnect: %lu ns\n"
-           ,ib_mem_dereg_ns, ib_destroy_qp_ns, ib_total_disconnect_ns);
-  #endif
-
   //  printf("Successfully destroyed all IB and RDMA CM objects\n");
 
   return rc;
diff --git a/src/rdma_server.c b/src/rdma_server.c
index 7d84a26..eaace88 100755
--- a/src/rdma_server.c
+++ b/src/rdma_server.c
@@ -15,11 +15,9 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <errno.h>
-#include <time.h>
 
 /* Project includes */
 #include <io/rdma.h>
-#include <util/timer.h>
 #include <debug.h>
 
 /* Directory includes */
@@ -40,22 +38,6 @@
 int
 ib_server_connect(struct ib_alloc *ib)
 {
-  /* Set up Timer  */ 
-  #ifdef TIMING    
-  //timer variable to store actual time  
-  uint64_t ib_mem_reg_ns = 0;    
-  uint64_t ib_create_qp_ns = 0;
-  uint64_t ib_total_conn_ns =0;
-  //sum of ib_total_conn_ns
-  uint64_t ib_total_conn_ns_sum=0;
-  TIMER_DECLARE1(ib_server_conn_timer);
-  TIMER_DECLARE1(ib_server_timer);
-  
-  //start timer for server total connection time 
-  TIMER_START(ib_server_conn_timer);
-  #endif
-
-
    /* 1. Set up RDMA CM structures */
 
     struct sockaddr_in addr;
@@ -87,21 +69,10 @@ ib_server_connect(struct ib_alloc *ib)
     if (rdma_listen(ib->rdma.listen_id, 1))
         return -1;
     
-    #ifdef TIMING
-    //stop timer to ignore wait blocks
-    TIMER_END(ib_server_conn_timer, ib_total_conn_ns);
-    ib_total_conn_ns_sum+= ib_total_conn_ns;
-    #endif
-
     printd("waiting for connection on port %d...\n", ib->params.port);
     if (rdma_get_cm_event(ib->rdma.ch, &ib->rdma.evt)) /* blocks */
         return -1;
 
-    #ifdef TIMING
-    //resume total connection timer
-    TIMER_START(ib_server_conn_timer);
-    #endif
-
     printd("got connection\n");
     if (ib->rdma.evt->event != RDMA_CM_EVENT_CONNECT_REQUEST)
         return -1;
@@ -136,20 +107,12 @@ ib_server_connect(struct ib_alloc *ib)
          IBV_ACCESS_REMOTE_READ |
          IBV_ACCESS_REMOTE_WRITE);
 
-    TIMER_START(ib_server_timer);
-
     if (!(ib->verbs.mr = ibv_reg_mr(ib->verbs.pd, (void*)ib->params.buf,
                     ib->params.buf_len, mr_flags))) {
         perror("RDMA memory registration");
         return -1;
     }
   
-    TIMER_END(ib_server_timer, ib_mem_reg_ns);
-
-
-    //Reset the timer so it can be reused
-    TIMER_CLEAR(ib_server_timer);
-  
     printd("registered memory region (%lu bytes)\n",
             ib->verbs.mr->length);
 
@@ -163,11 +126,9 @@ ib_server_connect(struct ib_alloc *ib)
 
     ib->verbs.qp_attr.qp_type = IBV_QPT_RC;
 
-    TIMER_START(ib_server_timer);
     if (rdma_create_qp(ib->rdma.id, ib->verbs.pd, &ib->verbs.qp_attr))
         return -1;
   
-    TIMER_END(ib_server_timer, ib_create_qp_ns);
       /* don't need to post a recv... */
 #if 0
     struct ibv_sge sge;
@@ -206,37 +167,14 @@ ib_server_connect(struct ib_alloc *ib)
     if (rdma_accept(ib->rdma.id, &ib->rdma.param))
         return -1;
 
-    #ifdef TIMING
-    //stop timer to ignore wait blocks
-    TIMER_END(ib_server_conn_timer, ib_total_conn_ns);
-    ib_total_conn_ns_sum+= ib_total_conn_ns;
-    #endif
-
     if (rdma_get_cm_event(ib->rdma.ch, &ib->rdma.evt))
         return -1;
 
-    #ifdef TIMING
-    //resume total connection timer
-    TIMER_START(ib_server_conn_timer);
-    #endif
-
     if (ib->rdma.evt->event != RDMA_CM_EVENT_ESTABLISHED)
         return -1;
 
     rdma_ack_cm_event(ib->rdma.evt);
   
-    #ifdef TIMING
-    //end total connection timer
-    TIMER_END(ib_server_conn_timer, ib_total_conn_ns);   
-    ib_total_conn_ns_sum+= ib_total_conn_ns;
-
-    //prints out all the timing results here
-    printf("[CONNECT] Time for ibv_reg_mr: %lu \n"         
-           "[CONNECT] Time for rdma_create_qp: %lu ns\n"
-           "[CONNECT] Time for total server connection: %lu ns\n",
-            ib_mem_reg_ns,ib_create_qp_ns, ib_total_conn_ns_sum);
-    #endif
-
     return 0;
 }
   int
@@ -261,41 +199,15 @@ ib_server_disconnect(struct ib_alloc *ib)
   //
   int rc = 0;
 
-  #ifdef TIMING    
-  uint64_t ib_total_disconnect_ns = 0;
-  uint64_t ib_destroy_qp_ns =0;
-  uint64_t ib_mem_dereg_ns = 0; 
-  TIMER_DECLARE1(ib_disconnect_timer);
-  TIMER_START(ib_disconnect_timer);
-
-  TIMER_DECLARE1(ib_dis_fine_timer);
-  TIMER_START(ib_dis_fine_timer);
-  #endif
-
    //Destroy the queue pair - returns void
     rdma_destroy_qp(ib->rdma.id);
-  #ifdef TIMING
-  TIMER_END(ib_dis_fine_timer, ib_destroy_qp_ns);
-  #endif
  
-    //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_dis_fine_timer);
-
   //------deregister pinned pages---------
-  #ifdef TIMING
-  TIMER_START(ib_dis_fine_timer);
-  #endif
   if (ibv_dereg_mr(ib->verbs.mr))
   {
     fprintf(stderr, "failed to deregister MR\n");
     rc = 1;
   }
-  #ifdef TIMING
-  TIMER_END(ib_dis_fine_timer, ib_mem_dereg_ns);
-  #endif
- //Reset the timer so it can be reused
-  TIMER_CLEAR(ib_dis_fine_timer);
-
 
   //Make sure to free the buffer, ib->ib_params.buf in the dealloc function
   //free(res->buf);
@@ -323,15 +235,5 @@ ib_server_disconnect(struct ib_alloc *ib)
 
   rdma_destroy_event_channel(ib->rdma.ch);
 
-  TIMER_END(ib_disconnect_timer, ib_total_disconnect_ns); 
- 
-  #ifdef TIMING
-  printf("[DISCONNECT] Time for ibv_dereg_mr: %lu ns\n"
-         "[DISCONNECT] Time for rdma_destroy_qp: %lu ns \n"
-         "[DISCONNECT] Total time for ib_server_disconnect: %lu ns\n"
-          ,ib_mem_dereg_ns, ib_destroy_qp_ns, ib_total_disconnect_ns); 
-  #endif
-
-
   return rc;
 }
diff --git a/test/SConscript b/test/SConscript
index 861d59e..4e88d52 100755
--- a/test/SConscript
+++ b/test/SConscript
@@ -21,9 +21,6 @@ libpath.extend(['../lib'])
 libs = ['ocm', 'rt','mpi']
 
 
-if int(ARGUMENTS.get('timing', 0)): # add timing macro to allow for use of in-place timers
-      ccflags.extend(['-DTIMING'])
-
 if int(ARGUMENTS.get('filter', 0)): # prefix gccfilter to assist with compilation
     gcc = gccfilter + gcc
 
diff --git a/test/extoll_rma_client.c b/test/extoll_rma_client.c
index 0cc34d8..95ed453 100644
--- a/test/extoll_rma_client.c
+++ b/test/extoll_rma_client.c
@@ -3,11 +3,9 @@
 #include <string.h>
 #include <unistd.h>
 #include <debug.h>
-#include <time.h>
 
 #include <io/extoll.h>
 #include "../src/extoll.h"
-#include <util/timer.h>
 #include <math.h>
 
 static unsigned int server_node_id;
@@ -35,18 +33,9 @@ static int teardown(extoll_t ex)
 {
     int ret = 0;
 
-    TIMER_DECLARE1(ex_disconnect_timer);
-    TIMER_START(ex_disconnect_timer);
-
     if (extoll_disconnect(ex, false/*is client*/))
       ret = 1;
 
-    #ifdef TIMING
-    uint64_t extoll_teardown_ns = 0;
-    TIMER_END(ex_disconnect_timer, extoll_teardown_ns);
-    printf("[DISCONNECT] Time for extoll_disconnect: %lu ns\n", extoll_teardown_ns);
-    #endif
-   
     //Free the IB structure
     if(extoll_free(ex))
       ret = -1;
diff --git a/test/extoll_rma_daemon.c b/test/extoll_rma_daemon.c
index a4db8ae..0162c66 100644
--- a/test/extoll_rma_daemon.c
+++ b/test/extoll_rma_daemon.c
@@ -31,18 +31,9 @@ static int teardown(extoll_t ex)
 {
   int ret = 0;
 
-  TIMER_DECLARE1(ex_disconnect_timer);
-  TIMER_START(ex_disconnect_timer);
-
   if (extoll_disconnect(ex, true/*is server*/))
     ret = -1;
 
-#ifdef TIMING
-  uint64_t extoll_teardown_ns = 0;
-  TIMER_END(ex_disconnect_timer, extoll_teardown_ns);
-  printf("[DISCONNECT] Time for extoll_disconnect: %lu ns\n", extoll_teardown_ns);
-#endif
-
   //Free the IB structure
   if(extoll_free(ex))
     ret = -1;
diff --git a/test/ib_client.c b/test/ib_client.c
index c89573b..8acaaa6 100755
--- a/test/ib_client.c
+++ b/test/ib_client.c
@@ -3,11 +3,9 @@
 #include <string.h>
 #include <unistd.h>
 #include <debug.h>
-#include <time.h>
 
 #include <io/rdma.h>
 #include "../src/rdma.h"
-#include <util/timer.h>
 #include <math.h>
 
 static char *serverIP = NULL;
@@ -22,7 +20,6 @@ static ib_t setup(struct ib_params *p)
     if (!(ib = ib_new(p)))
         return (ib_t)NULL;
 
-    //Don't time here due to blocking statements
     if (ib_connect(ib, false/*is client*/))
         return (ib_t)NULL;
 
@@ -34,18 +31,9 @@ static int teardown(ib_t ib)
 {
     int ret = 0;
 
-    TIMER_DECLARE1(ib_disconnect_timer);
-    TIMER_START(ib_disconnect_timer);
-
     if (ib_disconnect(ib, false/*is client*/))
       ret = 1;
 
-    #ifdef TIMING
-    uint64_t ib_teardown_ns = 0;
-    TIMER_END(ib_disconnect_timer, ib_teardown_ns);
-    printf("[DISCONNECT] Time for ib_disconnect: %lu ns\n", ib_teardown_ns);
-    #endif
-   
     //Free the IB structure
     if(ib_free(ib))
       ret = -1;
@@ -53,7 +41,7 @@ static int teardown(ib_t ib)
     return ret;
 }
 
-/* Does simple allocation test - for testing setup times*/
+/* Does simple allocation test */
 static int alloc_test(long long unsigned int size_B)
 {
     ib_t ib;
@@ -86,14 +74,6 @@ static int alloc_test(long long unsigned int size_B)
 /* write/read to/from remote memory timing test. */
 static int read_write_test()
 {
-    TIMER_DECLARE1(ib_read_timer);
-    TIMER_DECLARE1(ib_write_timer);
-    #ifdef TIMING
-    uint64_t ib_write_time_ns = 0;
-    uint64_t ib_read_time_ns = 0;
-    #endif
-    
-
     ib_t ib;
     struct ib_params params;
     char *buf = NULL;
@@ -123,41 +103,23 @@ static int read_write_test()
 
   while(size_B<=pow(2,30)){
 	len=size_B;
-	#ifdef TIMING
-	printf("------- %llu bytes -------\n", size_B);
-	#endif
  
-	#ifdef TIMING
-	TIMER_START(ib_write_timer);
 	if(ib_write(ib, 0, len)||ib_poll(ib))
 	{
 	    printf("write failed\n");
 	    return -1;
 	}
-	TIMER_END(ib_write_timer, ib_write_time_ns);
-	TIMER_CLEAR(ib_write_timer);
-	printf("[W] time to write %llu bytes: %lu \n", size_B, ib_write_time_ns);     
-	#endif 
 	memset(buf, 0, len);
     	size_B*=2;
 	}
 	// read back and wait for completion
       while(size_B2<=pow(2,30)){
-    	#ifdef TIMING
-	printf("------- %llu bytes -------\n", size_B2);
-	#endif
 	len=size_B2;
-	#ifdef TIMING
-	TIMER_START(ib_read_timer);
 	if(ib_read(ib, 0, len)||ib_poll(ib))
 	{
 	    printf("read failed\n");
 	    return -1;
 	}
-	TIMER_END(ib_read_timer, ib_read_time_ns);
-	TIMER_CLEAR(ib_read_timer);
-	printf("[R] time to read %llu bytes: %lu \n", len, ib_read_time_ns);
-	#endif
 	
 	size_B2*=2;
 	}
diff --git a/test/ib_daemon.c b/test/ib_daemon.c
index f061f2d..95f46f7 100755
--- a/test/ib_daemon.c
+++ b/test/ib_daemon.c
@@ -4,7 +4,6 @@
 #include <stdbool.h>
 
 #include <io/rdma.h>
-#include <util/timer.h>
 #include <math.h>
 #include "../src/rdma.h"
 
@@ -18,8 +17,6 @@ static ib_t setup(struct ib_params *p)
 	if (!(ib = ib_new(p)))
 		return (ib_t)NULL;
 
-  //We don't time this function because it has several blocking
-  //statements within which provide a false picture of timing.
   if (ib_connect(ib, true/*is server*/))
 	return (ib_t)NULL;
 
@@ -31,18 +28,9 @@ static int teardown(ib_t ib)
 {
   int ret = 0;
   
-  uint64_t ib_teardown_ns = 0;
-  TIMER_DECLARE1(ib_disconnect_timer);
-  TIMER_START(ib_disconnect_timer);
-
 	if (ib_disconnect(ib, true/*is server*/))
 		ret = -1;
 
-  TIMER_END(ib_disconnect_timer, ib_teardown_ns);
-  printf("[DISCONNECT] Time for ib_disconnect: %lu ns\n", ib_teardown_ns);
-  //Destroy the timer once we are done with it
-  //TIMER_DESTROY(ib_disconnect_timer);
-
   //Free the IB structure
   if(ib_free(ib))
     ret = -1;
@@ -79,7 +67,7 @@ static int alloc_test(long long unsigned int size_B)
 
 }
 
-/* read / write to/from memory timing test */
+/* read / write to/from memory */
 static int read_write_test(void){
 
 	ib_t ib;
